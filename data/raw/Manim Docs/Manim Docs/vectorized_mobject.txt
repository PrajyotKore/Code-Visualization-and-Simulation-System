vectorized_mobject
Mobjects that use vector graphics.

Classes

CurvesAsSubmobjects

Convert a curve's elements to submobjects.

DashedVMobject

A VMobject composed of dashes instead of lines.

VDict

A VGroup-like class, also offering submobject access by key, like a python dict

VGroup

A group of vectorized mobjects.

VMobject

A vectorized mobject.

VectorizedPoint






CurvesAsSubmobjects
Qualified name: manim.mobject.types.vectorized\_mobject.CurvesAsSubmobjects

class CurvesAsSubmobjects(vmobject, **kwargs)[source]
Bases: VGroup

Convert a curve’s elements to submobjects.

Examples

Example: LineGradientExample 

../_images/LineGradientExample-1.png
from manim import *

class LineGradientExample(Scene):
    def construct(self):
        curve = ParametricFunction(lambda t: [t, np.sin(t), 0], t_range=[-PI, PI, 0.01], stroke_width=10)
        new_curve = CurvesAsSubmobjects(curve)
        new_curve.set_color_by_gradient(BLUE, RED)
        self.add(new_curve.shift(UP), curve)
Make interactive
Methods

point_from_proportion

Gets the point at a proportion along the path of the CurvesAsSubmobjects.

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

Parameters:
vmobject (VMobject)

_original__init__(vmobject, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
vmobject (VMobject)

Return type:
None

point_from_proportion(alpha)[source]
Gets the point at a proportion along the path of the CurvesAsSubmobjects.

Parameters:
alpha (float) – The proportion along the the path of the CurvesAsSubmobjects.

Returns:
The point on the CurvesAsSubmobjects.

Return type:
numpy.ndarray

Raises:
ValueError – If alpha is not between 0 and 1.

Exception – If the CurvesAsSubmobjects has no submobjects, or no submobject has points










DashedVMobject
Qualified name: manim.mobject.types.vectorized\_mobject.DashedVMobject

class DashedVMobject(vmobject, num_dashes=15, dashed_ratio=0.5, dash_offset=0, color=ManimColor('#FFFFFF'), equal_lengths=True, **kwargs)[source]
Bases: VMobject

A VMobject composed of dashes instead of lines.

Parameters:
vmobject (VMobject) – The object that will get dashed

num_dashes (int) – Number of dashes to add.

dashed_ratio (float) – Ratio of dash to empty space.

dash_offset (float) – Shifts the starting point of dashes along the path. Value 1 shifts by one full dash length.

equal_lengths (bool) – If True, dashes will be (approximately) equally long. If False, dashes will be split evenly in the curve’s input t variable (legacy behavior).

color (ManimColor)

Examples

Example: DashedVMobjectExample 

../_images/DashedVMobjectExample-1.png
from manim import *

class DashedVMobjectExample(Scene):
    def construct(self):
        r = 0.5

        top_row = VGroup()  # Increasing num_dashes
        for dashes in range(1, 12):
            circ = DashedVMobject(Circle(radius=r, color=WHITE), num_dashes=dashes)
            top_row.add(circ)

        middle_row = VGroup()  # Increasing dashed_ratio
        for ratio in np.arange(1 / 11, 1, 1 / 11):
            circ = DashedVMobject(
                Circle(radius=r, color=WHITE), dashed_ratio=ratio
            )
            middle_row.add(circ)

        func1 = FunctionGraph(lambda t: t**5,[-1,1],color=WHITE)
        func_even = DashedVMobject(func1,num_dashes=6,equal_lengths=True)
        func_stretched = DashedVMobject(func1, num_dashes=6, equal_lengths=False)
        bottom_row = VGroup(func_even,func_stretched)

        top_row.arrange(buff=0.3)
        middle_row.arrange()
        bottom_row.arrange(buff=1)
        everything = VGroup(top_row, middle_row, bottom_row).arrange(DOWN, buff=1)
        self.add(everything)
Make interactive
Methods

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(vmobject, num_dashes=15, dashed_ratio=0.5, dash_offset=0, color=ManimColor('#FFFFFF'), equal_lengths=True, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
vmobject (VMobject)

num_dashes (int)

dashed_ratio (float)

dash_offset (float)

color (ManimColor)

equal_lengths (bool)

Return type:
None










VDict
Qualified name: manim.mobject.types.vectorized\_mobject.VDict

class VDict(mapping_or_iterable={}, show_keys=False, **kwargs)[source]
Bases: VMobject

A VGroup-like class, also offering submobject access by key, like a python dict

Parameters:
mapping_or_iterable (Mapping[Hashable, VMobject] | Iterable[tuple[Hashable, VMobject]]) – The parameter specifying the key-value mapping of keys and mobjects.

show_keys (bool) – Whether to also display the key associated with the mobject. This might be useful when debugging, especially when there are a lot of mobjects in the VDict. Defaults to False.

kwargs – Other arguments to be passed to Mobject.

show_keys
Whether to also display the key associated with the mobject. This might be useful when debugging, especially when there are a lot of mobjects in the VDict. When displayed, the key is towards the left of the mobject. Defaults to False.

Type:
bool

submob_dict
Is the actual python dictionary that is used to bind the keys to the mobjects.

Type:
dict

Examples

Example: ShapesWithVDict 

from manim import *

class ShapesWithVDict(Scene):
    def construct(self):
        square = Square().set_color(RED)
        circle = Circle().set_color(YELLOW).next_to(square, UP)

        # create dict from list of tuples each having key-mobject pair
        pairs = [("s", square), ("c", circle)]
        my_dict = VDict(pairs, show_keys=True)

        # display it just like a VGroup
        self.play(Create(my_dict))
        self.wait()

        text = Tex("Some text").set_color(GREEN).next_to(square, DOWN)

        # add a key-value pair by wrapping it in a single-element list of tuple
        # after attrs branch is merged, it will be easier like `.add(t=text)`
        my_dict.add([("t", text)])
        self.wait()

        rect = Rectangle().next_to(text, DOWN)
        # can also do key assignment like a python dict
        my_dict["r"] = rect

        # access submobjects like a python dict
        my_dict["t"].set_color(PURPLE)
        self.play(my_dict["t"].animate.scale(3))
        self.wait()

        # also supports python dict styled reassignment
        my_dict["t"] = Tex("Some other text").set_color(BLUE)
        self.wait()

        # remove submobject by key
        my_dict.remove("t")
        self.wait()

        self.play(Uncreate(my_dict["s"]))
        self.wait()

        self.play(FadeOut(my_dict["c"]))
        self.wait()

        self.play(FadeOut(my_dict["r"], shift=DOWN))
        self.wait()

        # you can also make a VDict from an existing dict of mobjects
        plain_dict = {
            1: Integer(1).shift(DOWN),
            2: Integer(2).shift(2 * DOWN),
            3: Integer(3).shift(3 * DOWN),
        }

        vdict_from_plain_dict = VDict(plain_dict)
        vdict_from_plain_dict.shift(1.5 * (UP + LEFT))
        self.play(Create(vdict_from_plain_dict))

        # you can even use zip
        vdict_using_zip = VDict(zip(["s", "c", "r"], [Square(), Circle(), Rectangle()]))
        vdict_using_zip.shift(1.5 * RIGHT)
        self.play(Create(vdict_using_zip))
        self.wait()
Make interactive
Methods

add

Adds the key-value pairs to the VDict object.

add_key_value_pair

A utility function used by add() to add the key-value pair to submob_dict.

get_all_submobjects

To get all the submobjects associated with a particular VDict object

remove

Removes the mobject from the VDict object having the key key

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_original__init__(mapping_or_iterable={}, show_keys=False, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
mapping_or_iterable (Mapping[Hashable, VMobject] | Iterable[tuple[Hashable, VMobject]])

show_keys (bool)

Return type:
None

add(mapping_or_iterable)[source]
Adds the key-value pairs to the VDict object.

Also, it internally adds the value to the submobjects list of Mobject, which is responsible for actual on-screen display.

Parameters:
mapping_or_iterable (Mapping[Hashable, VMobject] | Iterable[tuple[Hashable, VMobject]]) – The parameter specifying the key-value mapping of keys and mobjects.

Returns:
Returns the VDict object on which this method was called.

Return type:
VDict

Examples

Normal usage:

square_obj = Square()
my_dict.add([("s", square_obj)])
add_key_value_pair(key, value)[source]
A utility function used by add() to add the key-value pair to submob_dict. Not really meant to be used externally.

Parameters:
key (Hashable) – The key of the submobject to be added.

value (VMobject) – The mobject associated with the key

Return type:
None

Raises:
TypeError – If the value is not an instance of VMobject

Examples

Normal usage:

square_obj = Square()
self.add_key_value_pair("s", square_obj)
get_all_submobjects()[source]
To get all the submobjects associated with a particular VDict object

Returns:
All the submobjects associated with the VDict object

Return type:
dict_values

Examples

Normal usage:

for submob in my_dict.get_all_submobjects():
    self.play(Create(submob))
remove(key)[source]
Removes the mobject from the VDict object having the key key

Also, it internally removes the mobject from the submobjects list of Mobject, (which is responsible for removing it from the screen)

Parameters:
key (Hashable) – The key of the submoject to be removed.

Returns:
Returns the VDict object on which this method was called.

Return type:
VDict

Examples

Normal usage:

my_dict.remove("square")












VGroup
Qualified name: manim.mobject.types.vectorized\_mobject.VGroup

class VGroup(*vmobjects, **kwargs)[source]
Bases: VMobject

A group of vectorized mobjects.

This can be used to group multiple VMobject instances together in order to scale, move, … them together.

Notes

When adding the same mobject more than once, repetitions are ignored. Use Mobject.copy() to create a separate copy which can then be added to the group.

Examples

To add VGroup, you can either use the add() method, or use the + and += operators. Similarly, you can subtract elements of a VGroup via remove() method, or - and -= operators:

from manim import Triangle, Square, VGroup
vg = VGroup()
triangle, square = Triangle(), Square()
vg.add(triangle)
VGroup(Triangle)
vg + square  # a new VGroup is constructed
VGroup(Triangle, Square)
vg  # not modified
VGroup(Triangle)
vg += square
vg  # modifies vg
VGroup(Triangle, Square)
vg.remove(triangle)
VGroup(Square)
vg - square  # a new VGroup is constructed
VGroup()
vg  # not modified
VGroup(Square)
vg -= square
vg  # modifies vg
VGroup()
Example: ArcShapeIris 

../_images/ArcShapeIris-1.png
from manim import *

class ArcShapeIris(Scene):
    def construct(self):
        colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]
        radius = [1 + rad * 0.1 for rad in range(len(colors))]

        circles_group = VGroup()

        # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]
        circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)
                            for rad, col in zip(radius, colors)])
        self.add(circles_group)
Make interactive
Methods

add

Checks if all passed elements are an instance, or iterables of VMobject and then adds them to submobjects

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

Parameters:
vmobjects (VMobject | Iterable[VMobject])

kwargs (Any)

_original__init__(*vmobjects, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
vmobjects (VMobject | Iterable[VMobject])

kwargs (Any)

Return type:
None

add(*vmobjects)[source]
Checks if all passed elements are an instance, or iterables of VMobject and then adds them to submobjects

Parameters:
vmobjects (VMobject | Iterable[VMobject]) – List or iterable of VMobjects to add

Return type:
VGroup

Raises:
TypeError – If one element of the list, or iterable is not an instance of VMobject

Examples

The following example shows how to add individual or multiple VMobject instances through the VGroup constructor and its .add() method.

Example: AddToVGroup 

from manim import *

class AddToVGroup(Scene):
    def construct(self):
        circle_red = Circle(color=RED)
        circle_green = Circle(color=GREEN)
        circle_blue = Circle(color=BLUE)
        circle_red.shift(LEFT)
        circle_blue.shift(RIGHT)
        gr = VGroup(circle_red, circle_green)
        gr2 = VGroup(circle_blue) # Constructor uses add directly
        self.add(gr,gr2)
        self.wait()
        gr += gr2 # Add group to another
        self.play(
            gr.animate.shift(DOWN),
        )
        gr -= gr2 # Remove group
        self.play( # Animate groups separately
            gr.animate.shift(LEFT),
            gr2.animate.shift(UP),
        )
        self.play( #Animate groups without modification
            (gr+gr2).animate.shift(RIGHT)
        )
        self.play( # Animate group without component
            (gr-circle_red).animate.shift(RIGHT)
        )
Make interactive
A VGroup can be created using iterables as well. Keep in mind that all generated values from an iterable must be an instance of VMobject. This is demonstrated below:

Example: AddIterableToVGroupExample 

../_images/AddIterableToVGroupExample-1.png
from manim import *

class AddIterableToVGroupExample(Scene):
    def construct(self):
        v = VGroup(
            Square(),               # Singular VMobject instance
            [Circle(), Triangle()], # List of VMobject instances
            Dot(),
            (Dot() for _ in range(2)), # Iterable that generates VMobjects
        )
        v.arrange()
        self.add(v)
Make interactive
To facilitate this, the iterable is unpacked before its individual instances are added to the VGroup. As a result, when you index a VGroup, you will never get back an iterable. Instead, you will always receive VMobject instances, including those that were part of the iterable/s that you originally added to the VGroup.















VMobject
Qualified name: manim.mobject.types.vectorized\_mobject.VMobject

class VMobject(fill_color=None, fill_opacity=0.0, stroke_color=None, stroke_opacity=1.0, stroke_width=4, background_stroke_color=ManimColor('#000000'), background_stroke_opacity=1.0, background_stroke_width=0, sheen_factor=0.0, joint_type=None, sheen_direction=array([-1., 1., 0.]), close_new_points=False, pre_function_handle_to_anchor_scale_factor=0.01, make_smooth_after_applying_functions=False, background_image=None, shade_in_3d=False, tolerance_for_point_equality=1e-06, n_points_per_cubic_curve=4, cap_style=CapStyleType.AUTO, **kwargs)[source]
Bases: Mobject

A vectorized mobject.

Parameters:
background_stroke_color (ParsableManimColor | None) – The purpose of background stroke is to have something that won’t overlap fill, e.g. For text against some textured background.

sheen_factor (float) – When a color c is set, there will be a second color computed based on interpolating c to WHITE by with sheen_factor, and the display will gradient to this secondary color in the direction of sheen_direction.

close_new_points (bool) – Indicates that it will not be displayed, but that it should count in parent mobject’s path

tolerance_for_point_equality (float) – This is within a pixel

joint_type (LineJointType | None) – The line joint type used to connect the curve segments of this vectorized mobject. See LineJointType for options.

fill_color (ParsableManimColor | None)

fill_opacity (float)

stroke_color (ParsableManimColor | None)

stroke_opacity (float)

stroke_width (float)

background_stroke_opacity (float)

background_stroke_width (float)

sheen_direction (Vector3D)

pre_function_handle_to_anchor_scale_factor (float)

make_smooth_after_applying_functions (bool)

background_image (Image | str | None)

shade_in_3d (bool)

n_points_per_cubic_curve (int)

cap_style (CapStyleType)

kwargs (Any)

Methods

add_cubic_bezier_curve

add_cubic_bezier_curve_to

Add cubic bezier curve to the path.

add_cubic_bezier_curves

add_line_to

Add a straight line from the last point of VMobject to the given point.

add_points_as_corners

Append multiple straight lines at the end of VMobject.points, which connect the given points in order starting from the end of the current path.

add_quadratic_bezier_curve_to

Add Quadratic bezier curve to the path.

add_smooth_curve_to

Creates a smooth curve from given points and add it to the VMobject.

add_subpath

align_points

Adds points to self and vmobject so that they both have the same number of subpaths, with corresponding subpaths each containing the same number of points.

align_rgbas

append_points

Append the given new_points to the end of VMobject.points.

append_vectorized_mobject

apply_function

change_anchor_mode

Changes the anchor mode of the bezier curves.

clear_points

close_path

color_using_background_image

consider_points_equals

consider_points_equals_2d

Determine if two points are close enough to be considered equal.

fade

force_direction

Makes sure that points are either directed clockwise or counterclockwise.

gen_cubic_bezier_tuples_from_points

Returns the bezier tuples from an array of points.

gen_subpaths_from_points_2d

generate_rgbas_array

First arg can be either a color, or a tuple/list of colors.

get_anchors

Returns the anchors of the curves forming the VMobject.

get_anchors_and_handles

Returns anchors1, handles1, handles2, anchors2, where (anchors1[i], handles1[i], handles2[i], anchors2[i]) will be four points defining a cubic bezier curve for any i in range(0, len(anchors1))

get_arc_length

Return the approximated length of the whole curve.

get_background_image

get_color

Returns the color of the Mobject

get_cubic_bezier_tuples

get_cubic_bezier_tuples_from_points

get_curve_functions

Gets the functions for the curves of the mobject.

get_curve_functions_with_lengths

Gets the functions and lengths of the curves for the mobject.

get_direction

Uses shoelace_direction() to calculate the direction.

get_end_anchors

Return the end anchors of the bezier curves.

get_fill_color

If there are multiple colors (for gradient) this returns the first one

get_fill_colors

get_fill_opacities

get_fill_opacity

If there are multiple opacities, this returns the first

get_fill_rgbas

get_gradient_start_and_end_points

get_group_class

get_last_point

get_mobject_type_class

Return the base class of this mobject type.

get_nth_curve_function

Returns the expression of the nth curve.

get_nth_curve_function_with_length

Returns the expression of the nth curve along with its (approximate) length.

get_nth_curve_length

Returns the (approximate) length of the nth curve.

get_nth_curve_length_pieces

Returns the array of short line lengths used for length approximation.

get_nth_curve_points

Returns the points defining the nth curve of the vmobject.

get_num_curves

Returns the number of curves of the vmobject.

get_point_mobject

The simplest Mobject to be transformed to or from self.

get_points_defining_boundary

get_sheen_direction

get_sheen_factor

get_start_anchors

Returns the start anchors of the bezier curves.

get_stroke_color

get_stroke_colors

get_stroke_opacities

get_stroke_opacity

get_stroke_rgbas

get_stroke_width

get_style

get_subcurve

Returns the subcurve of the VMobject between the interval [a, b].

get_subpaths

Returns subpaths formed by the curves of the VMobject.

get_subpaths_from_points

has_new_path_started

init_colors

Initializes the colors.

insert_n_curves

Inserts n curves to the bezier curves of the vmobject.

insert_n_curves_to_point_list

Given an array of k points defining a bezier curves (anchors and handles), returns points defining exactly k + n bezier curves.

interpolate_color

is_closed

make_jagged

make_smooth

match_background_image

match_style

point_from_proportion

Gets the point at a proportion along the path of the VMobject.

pointwise_become_partial

Given a 2nd VMobject vmobject, a lower bound a and an upper bound b, modify this VMobject's points to match the portion of the Bézier spline described by vmobject.points with the parameter t between a and b.

proportion_from_point

Returns the proportion along the path of the VMobject a particular given point is at.

resize_points

Resize the array of anchor points and handles to have the specified size.

reverse_direction

Reverts the point direction by inverting the point order.

rotate

Rotates the Mobject about a certain point.

rotate_sheen_direction

Rotates the direction of the applied sheen.

scale

Scale the size by a factor.

scale_handle_to_anchor_distances

If the distance between a given handle point H and its associated anchor point A is d, then it changes H to be a distances factor*d away from A, but so that the line from A to H doesn't change.

set_anchors_and_handles

Given two sets of anchors and handles, process them to set them as anchors and handles of the VMobject.

set_background_stroke

set_cap_style

Sets the cap style of the VMobject.

set_color

Condition is function which takes in one arguments, (x, y, z).

set_fill

Set the fill color and fill opacity of a VMobject.

set_opacity

set_points

set_points_as_corners

Given an array of points, set them as corners of the VMobject.

set_points_smoothly

set_shade_in_3d

set_sheen

Applies a color gradient from a direction.

set_sheen_direction

Sets the direction of the applied sheen.

set_stroke

set_style

start_new_path

Append a point to the VMobject.points, which will be the beginning of a new Bézier curve in the path given by the points.

update_rgbas_array

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

_assert_valid_submobjects(submobjects)[source]
Check that all submobjects are actually instances of Mobject, and that none of them is self (a Mobject cannot contain itself).

This is an auxiliary function called when adding Mobjects to the submobjects list.

This function is intended to be overridden by subclasses such as VMobject, which should assert that only other VMobjects may be added into it.

Parameters:
submobjects (Iterable[VMobject]) – The list containing values to validate.

Returns:
The Mobject itself.

Return type:
Mobject

Raises:
TypeError – If any of the values in submobjects is not a Mobject.

ValueError – If there was an attempt to add a Mobject as its own submobject.

_gen_subpaths_from_points(points, filter_func)[source]
Given an array of points defining the bezier curves of the vmobject, return subpaths formed by these points. Here, Two bezier curves form a path if at least two of their anchors are evaluated True by the relation defined by filter_func.

The algorithm every bezier tuple (anchors and handles) in self.points (by regrouping each n elements, where n is the number of points per cubic curve)), and evaluate the relation between two anchors with filter_func. NOTE : The filter_func takes an int n as parameter, and will evaluate the relation between points[n] and points[n - 1]. This should probably be changed so the function takes two points as parameters.

Parameters:
points (CubicBezierPath) – points defining the bezier curve.

filter_func (Callable[[int], bool]) – Filter-func defining the relation.

Returns:
subpaths formed by the points.

Return type:
Iterable[CubicSpline]

_original__init__(fill_color=None, fill_opacity=0.0, stroke_color=None, stroke_opacity=1.0, stroke_width=4, background_stroke_color=ManimColor('#000000'), background_stroke_opacity=1.0, background_stroke_width=0, sheen_factor=0.0, joint_type=None, sheen_direction=array([-1., 1., 0.]), close_new_points=False, pre_function_handle_to_anchor_scale_factor=0.01, make_smooth_after_applying_functions=False, background_image=None, shade_in_3d=False, tolerance_for_point_equality=1e-06, n_points_per_cubic_curve=4, cap_style=CapStyleType.AUTO, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
fill_color (ParsableManimColor | None)

fill_opacity (float)

stroke_color (ParsableManimColor | None)

stroke_opacity (float)

stroke_width (float)

background_stroke_color (ParsableManimColor | None)

background_stroke_opacity (float)

background_stroke_width (float)

sheen_factor (float)

joint_type (LineJointType | None)

sheen_direction (Vector3D)

close_new_points (bool)

pre_function_handle_to_anchor_scale_factor (float)

make_smooth_after_applying_functions (bool)

background_image (Image | str | None)

shade_in_3d (bool)

tolerance_for_point_equality (float)

n_points_per_cubic_curve (int)

cap_style (CapStyleType)

kwargs (Any)

add_cubic_bezier_curve_to(handle1, handle2, anchor)[source]
Add cubic bezier curve to the path.

NOTE : the first anchor is not a parameter as by default the end of the last sub-path!

Parameters:
handle1 (Point3DLike) – first handle

handle2 (Point3DLike) – second handle

anchor (Point3DLike) – anchor

Returns:
self

Return type:
VMobject

add_line_to(point)[source]
Add a straight line from the last point of VMobject to the given point.

Parameters:
point (Point3DLike) – The end of the straight line.

Returns:
self

Return type:
VMobject

add_points_as_corners(points)[source]
Append multiple straight lines at the end of VMobject.points, which connect the given points in order starting from the end of the current path. These points would be therefore the corners of the new polyline appended to the path.

Parameters:
points (Point3DLike_Array) – An array of 3D points representing the corners of the polyline to append to VMobject.points.

Returns:
The VMobject itself, after appending the straight lines to its path.

Return type:
VMobject

add_quadratic_bezier_curve_to(handle, anchor)[source]
Add Quadratic bezier curve to the path.

Returns:
self

Return type:
VMobject

Parameters:
handle (Point3DLike)

anchor (Point3DLike)

add_smooth_curve_to(*points)[source]
Creates a smooth curve from given points and add it to the VMobject. If two points are passed in, the first is interpreted as a handle, the second as an anchor.

Parameters:
points (Point3DLike) – Points (anchor and handle, or just anchor) to add a smooth curve from

Returns:
self

Return type:
VMobject

Raises:
ValueError – If 0 or more than 2 points are given.

align_points(vmobject)[source]
Adds points to self and vmobject so that they both have the same number of subpaths, with corresponding subpaths each containing the same number of points.

Points are added either by subdividing curves evenly along the subpath, or by creating new subpaths consisting of a single point repeated.

Parameters:
vmobject (VMobject) – The object to align points with.

Returns:
self

Return type:
VMobject

append_points(new_points)[source]
Append the given new_points to the end of VMobject.points.

Parameters:
new_points (Point3DLike_Array) – An array of 3D points to append.

Returns:
The VMobject itself, after appending new_points.

Return type:
VMobject

change_anchor_mode(mode)[source]
Changes the anchor mode of the bezier curves. This will modify the handles.

There can be only two modes, “jagged”, and “smooth”.

Returns:
self

Return type:
VMobject

Parameters:
mode (Literal['jagged', 'smooth'])

consider_points_equals_2d(p0, p1)[source]
Determine if two points are close enough to be considered equal.

This uses the algorithm from np.isclose(), but expanded here for the 2D point case. NumPy is overkill for such a small question. :param p0: first point :param p1: second point

Returns:
whether two points considered close.

Return type:
bool

Parameters:
p0 (Point2DLike)

p1 (Point2DLike)

property fill_color: ManimColor
If there are multiple colors (for gradient) this returns the first one

force_direction(target_direction)[source]
Makes sure that points are either directed clockwise or counterclockwise.

Parameters:
target_direction (Literal['CW', 'CCW']) – Either "CW" or "CCW".

Return type:
Self

gen_cubic_bezier_tuples_from_points(points)[source]
Returns the bezier tuples from an array of points.

self.points is a list of the anchors and handles of the bezier curves of the mobject (ie [anchor1, handle1, handle2, anchor2, anchor3 ..]) This algorithm basically retrieve them by taking an element every n, where n is the number of control points of the bezier curve.

Parameters:
points (CubicBezierPathLike) – Points from which control points will be extracted.

Returns:
Bezier control points.

Return type:
tuple

generate_rgbas_array(color, opacity)[source]
First arg can be either a color, or a tuple/list of colors. Likewise, opacity can either be a float, or a tuple of floats. If self.sheen_factor is not zero, and only one color was passed in, a second slightly light color will automatically be added for the gradient

Parameters:
color (ManimColor | list[ManimColor])

opacity (float | Iterable[float])

Return type:
RGBA_Array_Float

get_anchors()[source]
Returns the anchors of the curves forming the VMobject.

Returns:
The anchors.

Return type:
Point3D_Array

get_anchors_and_handles()[source]
Returns anchors1, handles1, handles2, anchors2, where (anchors1[i], handles1[i], handles2[i], anchors2[i]) will be four points defining a cubic bezier curve for any i in range(0, len(anchors1))

Returns:
Iterable of the anchors and handles.

Return type:
list[Point3D_Array]

get_arc_length(sample_points_per_curve=None)[source]
Return the approximated length of the whole curve.

Parameters:
sample_points_per_curve (int | None) – Number of sample points per curve used to approximate the length. More points result in a better approximation.

Returns:
The length of the VMobject.

Return type:
float

get_color()[source]
Returns the color of the Mobject

Examples

from manim import Square, RED
Square(color=RED).get_color() == RED
True
Return type:
ManimColor

get_curve_functions()[source]
Gets the functions for the curves of the mobject.

Returns:
The functions for the curves.

Return type:
Iterable[Callable[[float], Point3D]]

get_curve_functions_with_lengths(**kwargs)[source]
Gets the functions and lengths of the curves for the mobject.

Parameters:
**kwargs – The keyword arguments passed to get_nth_curve_function_with_length()

Returns:
The functions and lengths of the curves.

Return type:
Iterable[tuple[Callable[[float], Point3D], float]]

get_direction()[source]
Uses shoelace_direction() to calculate the direction. The direction of points determines in which direction the object is drawn, clockwise or counterclockwise.

Examples

The default direction of a Circle is counterclockwise:

from manim import Circle
Circle().get_direction()
'CCW'
Returns:
Either "CW" or "CCW".

Return type:
str

get_end_anchors()[source]
Return the end anchors of the bezier curves.

Returns:
Starting anchors

Return type:
Point3D_Array

get_fill_color()[source]
If there are multiple colors (for gradient) this returns the first one

Return type:
ManimColor

get_fill_opacity()[source]
If there are multiple opacities, this returns the first

Return type:
ManimFloat

static get_mobject_type_class()[source]
Return the base class of this mobject type.

Return type:
type[VMobject]

get_nth_curve_function(n)[source]
Returns the expression of the nth curve.

Parameters:
n (int) – index of the desired curve.

Returns:
expression of the nth bezier curve.

Return type:
Callable[float, Point3D]

get_nth_curve_function_with_length(n, sample_points=None)[source]
Returns the expression of the nth curve along with its (approximate) length.

Parameters:
n (int) – The index of the desired curve.

sample_points (int | None) – The number of points to sample to find the length.

Returns:
curve (Callable[[float], Point3D]) – The function for the nth curve.

length (float) – The length of the nth curve.

Return type:
tuple[Callable[[float], Point3D], float]

get_nth_curve_length(n, sample_points=None)[source]
Returns the (approximate) length of the nth curve.

Parameters:
n (int) – The index of the desired curve.

sample_points (int | None) – The number of points to sample to find the length.

Returns:
length – The length of the nth curve.

Return type:
float

get_nth_curve_length_pieces(n, sample_points=None)[source]
Returns the array of short line lengths used for length approximation.

Parameters:
n (int) – The index of the desired curve.

sample_points (int | None) – The number of points to sample to find the length.

Return type:
The short length-pieces of the nth curve.

get_nth_curve_points(n)[source]
Returns the points defining the nth curve of the vmobject.

Parameters:
n (int) – index of the desired bezier curve.

Returns:
points defining the nth bezier curve (anchors, handles)

Return type:
CubicBezierPoints

get_num_curves()[source]
Returns the number of curves of the vmobject.

Returns:
number of curves of the vmobject.

Return type:
int

get_point_mobject(center=None)[source]
The simplest Mobject to be transformed to or from self. Should by a point of the appropriate type

Parameters:
center (Point3DLike | None)

Return type:
VectorizedPoint

get_start_anchors()[source]
Returns the start anchors of the bezier curves.

Returns:
Starting anchors

Return type:
Point3D_Array

get_subcurve(a, b)[source]
Returns the subcurve of the VMobject between the interval [a, b]. The curve is a VMobject itself.

Parameters:
a (float) – The lower bound.

b (float) – The upper bound.

Returns:
The subcurve between of [a, b]

Return type:
VMobject

get_subpaths()[source]
Returns subpaths formed by the curves of the VMobject.

Subpaths are ranges of curves with each pair of consecutive curves having their end/start points coincident.

Returns:
subpaths.

Return type:
list[CubicSpline]

init_colors(propagate_colors=True)[source]
Initializes the colors.

Gets called upon creation. This is an empty method that can be implemented by subclasses.

Parameters:
propagate_colors (bool)

Return type:
Self

insert_n_curves(n)[source]
Inserts n curves to the bezier curves of the vmobject.

Parameters:
n (int) – Number of curves to insert.

Returns:
self

Return type:
VMobject

insert_n_curves_to_point_list(n, points)[source]
Given an array of k points defining a bezier curves (anchors and handles), returns points defining exactly k + n bezier curves.

Parameters:
n (int) – Number of desired curves.

points (BezierPathLike) – Starting points.

Return type:
Points generated.

point_from_proportion(alpha)[source]
Gets the point at a proportion along the path of the VMobject.

Parameters:
alpha (float) – The proportion along the the path of the VMobject.

Returns:
The point on the VMobject.

Return type:
numpy.ndarray

Raises:
ValueError – If alpha is not between 0 and 1.

Exception – If the VMobject has no points.

Example

Example: PointFromProportion 

../_images/PointFromProportion-1.png
from manim import *

class PointFromProportion(Scene):
    def construct(self):
        line = Line(2*DL, 2*UR)
        self.add(line)
        colors = (RED, BLUE, YELLOW)
        proportions = (1/4, 1/2, 3/4)
        for color, proportion in zip(colors, proportions):
            self.add(Dot(color=color).move_to(
                    line.point_from_proportion(proportion)
            ))
Make interactive
pointwise_become_partial(vmobject, a, b)[source]
Given a 2nd VMobject vmobject, a lower bound a and an upper bound b, modify this VMobject’s points to match the portion of the Bézier spline described by vmobject.points with the parameter t between a and b.

Parameters:
vmobject (VMobject) – The VMobject that will serve as a model.

a (float) – The lower bound for t.

b (float) – The upper bound for t

Returns:
The VMobject itself, after the transformation.

Return type:
VMobject

Raises:
TypeError – If vmobject is not an instance of VMobject.

proportion_from_point(point)[source]
Returns the proportion along the path of the VMobject a particular given point is at.

Parameters:
point (Point3DLike) – The Cartesian coordinates of the point which may or may not lie on the VMobject

Returns:
The proportion along the path of the VMobject.

Return type:
float

Raises:
ValueError – If point does not lie on the curve.

Exception – If the VMobject has no points.

resize_points(new_length, resize_func=<function resize_array>)[source]
Resize the array of anchor points and handles to have the specified size.

Parameters:
new_length (int) – The new (total) number of points.

resize_func (Callable[[Point3D_Array, int], Point3D_Array]) – A function mapping a Numpy array (the points) and an integer (the target size) to a Numpy array. The default implementation is based on Numpy’s resize function.

Return type:
Self

reverse_direction()[source]
Reverts the point direction by inverting the point order.

Returns:
Returns self.

Return type:
VMobject

Examples

Example: ChangeOfDirection 

from manim import *

class ChangeOfDirection(Scene):
    def construct(self):
        ccw = RegularPolygon(5)
        ccw.shift(LEFT)
        cw = RegularPolygon(5)
        cw.shift(RIGHT).reverse_direction()

        self.play(Create(ccw), Create(cw),
        run_time=4)
Make interactive
rotate(angle, axis=array([0., 0., 1.]), about_point=None, **kwargs)[source]
Rotates the Mobject about a certain point.

Parameters:
angle (float)

axis (Vector3D)

about_point (Point3DLike | None)

Return type:
Self

rotate_sheen_direction(angle, axis=array([0., 0., 1.]), family=True)[source]
Rotates the direction of the applied sheen.

Parameters:
angle (float) – Angle by which the direction of sheen is rotated.

axis (Vector3D) – Axis of rotation.

family (bool)

Return type:
Self

Examples

Normal usage:

Circle().set_sheen_direction(UP).rotate_sheen_direction(PI)
See also

set_sheen_direction()

scale(scale_factor, scale_stroke=False, **kwargs)[source]
Scale the size by a factor.

Default behavior is to scale about the center of the vmobject.

Parameters:
scale_factor (float) – The scaling factor 
. If 
, the mobject will shrink, and for 
 it will grow. Furthermore, if 
, the mobject is also flipped.

scale_stroke (bool) – Boolean determining if the object’s outline is scaled when the object is scaled. If enabled, and object with 2px outline is scaled by a factor of .5, it will have an outline of 1px.

kwargs – Additional keyword arguments passed to scale().

Returns:
self

Return type:
VMobject

Examples

Example: MobjectScaleExample 

../_images/MobjectScaleExample-3.png
from manim import *

class MobjectScaleExample(Scene):
    def construct(self):
        c1 = Circle(1, RED).set_x(-1)
        c2 = Circle(1, GREEN).set_x(1)

        vg = VGroup(c1, c2)
        vg.set_stroke(width=50)
        self.add(vg)

        self.play(
            c1.animate.scale(.25),
            c2.animate.scale(.25,
                scale_stroke=True)
        )
Make interactive
See also

move_to()

scale_handle_to_anchor_distances(factor)[source]
If the distance between a given handle point H and its associated anchor point A is d, then it changes H to be a distances factor*d away from A, but so that the line from A to H doesn’t change. This is mostly useful in the context of applying a (differentiable) function, to preserve tangency properties. One would pull all the handles closer to their anchors, apply the function then push them out again.

Parameters:
factor (float) – The factor used for scaling.

Returns:
self

Return type:
VMobject

set_anchors_and_handles(anchors1, handles1, handles2, anchors2)[source]
Given two sets of anchors and handles, process them to set them as anchors and handles of the VMobject.

anchors1[i], handles1[i], handles2[i] and anchors2[i] define the i-th bezier curve of the vmobject. There are four hardcoded parameters and this is a problem as it makes the number of points per cubic curve unchangeable from 4 (two anchors and two handles).

Returns:
self

Return type:
VMobject

Parameters:
anchors1 (Point3DLike_Array)

handles1 (Point3DLike_Array)

handles2 (Point3DLike_Array)

anchors2 (Point3DLike_Array)

set_cap_style(cap_style)[source]
Sets the cap style of the VMobject.

Parameters:
cap_style (CapStyleType) – The cap style to be set. See CapStyleType for options.

Returns:
self

Return type:
VMobject

Examples

Example: CapStyleExample 

../_images/CapStyleExample-1.png
from manim import *

class CapStyleExample(Scene):
    def construct(self):
        line = Line(LEFT, RIGHT, color=YELLOW, stroke_width=20)
        line.set_cap_style(CapStyleType.ROUND)
        self.add(line)
Make interactive
set_color(color, family=True)[source]
Condition is function which takes in one arguments, (x, y, z). Here it just recurses to submobjects, but in subclasses this should be further implemented based on the the inner workings of color

Parameters:
color (ParsableManimColor)

family (bool)

Return type:
Self

set_fill(color=None, opacity=None, family=True)[source]
Set the fill color and fill opacity of a VMobject.

Parameters:
color (ParsableManimColor | None) – Fill color of the VMobject.

opacity (float | None) – Fill opacity of the VMobject.

family (bool) – If True, the fill color of all submobjects is also set.

Returns:
self

Return type:
VMobject

Examples

Example: SetFill 

../_images/SetFill-1.png
from manim import *

class SetFill(Scene):
    def construct(self):
        square = Square().scale(2).set_fill(WHITE,1)
        circle1 = Circle().set_fill(GREEN,0.8)
        circle2 = Circle().set_fill(YELLOW) # No fill_opacity
        circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)
        group = Group(circle1,circle2,circle3).arrange()
        self.add(square)
        self.add(group)
Make interactive
See also

set_style()

set_points_as_corners(points)[source]
Given an array of points, set them as corners of the VMobject.

To achieve that, this algorithm sets handles aligned with the anchors such that the resultant Bézier curve will be the segment between the two anchors.

Parameters:
points (Point3DLike_Array) – Array of points that will be set as corners.

Returns:
The VMobject itself, after setting the new points as corners.

Return type:
VMobject

Examples

Example: PointsAsCornersExample 

../_images/PointsAsCornersExample-1.png
from manim import *

class PointsAsCornersExample(Scene):
    def construct(self):
        corners = (
            # create square
            UR, UL,
            DL, DR,
            UR,
            # create crosses
            DL, UL,
            DR
        )
        vmob = VMobject(stroke_color=RED)
        vmob.set_points_as_corners(corners).scale(2)
        self.add(vmob)
Make interactive
set_sheen(factor, direction=None, family=True)[source]
Applies a color gradient from a direction.

Parameters:
factor (float) – The extent of lustre/gradient to apply. If negative, the gradient starts from black, if positive the gradient starts from white and changes to the current color.

direction (Vector3D | None) – Direction from where the gradient is applied.

family (bool)

Return type:
Self

Examples

Example: SetSheen 

../_images/SetSheen-1.png
from manim import *

class SetSheen(Scene):
    def construct(self):
        circle = Circle(fill_opacity=1).set_sheen(-0.3, DR)
        self.add(circle)
Make interactive
set_sheen_direction(direction, family=True)[source]
Sets the direction of the applied sheen.

Parameters:
direction (Vector3D) – Direction from where the gradient is applied.

family (bool)

Return type:
Self

Examples

Normal usage:

Circle().set_sheen_direction(UP)
See also

set_sheen(), rotate_sheen_direction()

start_new_path(point)[source]
Append a point to the VMobject.points, which will be the beginning of a new Bézier curve in the path given by the points. If there’s an unfinished curve at the end of VMobject.points, complete it by appending the last Bézier curve’s start anchor as many times as needed.

Parameters:
point (Point3DLike) – A 3D point to append to VMobject.points.

Returns:
The VMobject itself, after appending point and starting a new curve.

Return type:
VMobject







VectorizedPoint
Qualified name: manim.mobject.types.vectorized\_mobject.VectorizedPoint

class VectorizedPoint(location=array([0., 0., 0.]), color=ManimColor('#000000'), fill_opacity=0, stroke_width=0, artificial_width=0.01, artificial_height=0.01, **kwargs)[source]
Bases: VMobject

Methods

get_location

set_location

Attributes

animate

Used to animate the application of any method of self.

animation_overrides

color

depth

The depth of the mobject.

fill_color

If there are multiple colors (for gradient) this returns the first one

height

The height of the mobject.

n_points_per_curve

sheen_factor

stroke_color

width

The width of the mobject.

Parameters:
location (Point3DLike)

color (ManimColor)

fill_opacity (float)

stroke_width (float)

artificial_width (float)

artificial_height (float)

_original__init__(location=array([0., 0., 0.]), color=ManimColor('#000000'), fill_opacity=0, stroke_width=0, artificial_width=0.01, artificial_height=0.01, **kwargs)
Initialize self. See help(type(self)) for accurate signature.

Parameters:
location (Point3DLike)

color (ManimColor)

fill_opacity (float)

stroke_width (float)

artificial_width (float)

artificial_height (float)

Return type:
None

basecls
alias of VMobject

property height: float
The height of the mobject.

Return type:
float

Examples

Example: HeightExample 

from manim import *

class HeightExample(Scene):
    def construct(self):
        decimal = DecimalNumber().to_edge(UP)
        rect = Rectangle(color=BLUE)
        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)

        decimal.add_updater(lambda d: d.set_value(rect.height))

        self.add(rect_copy, rect, decimal)
        self.play(rect.animate.set(height=5))
        self.wait()
Make interactive
See also

length_over_dim()

property width: float
The width of the mobject.

Return type:
float

Examples

Example: WidthExample 

from manim import *

class WidthExample(Scene):
    def construct(self):
        decimal = DecimalNumber().to_edge(UP)
        rect = Rectangle(color=BLUE)
        rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)

        decimal.add_updater(lambda d: d.set_value(rect.width))

        self.add(rect_copy, rect, decimal)
        self.play(rect.animate.set(width=7))
        self.wait()
Make interactive
See also